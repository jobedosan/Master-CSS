body {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
}

/* FLEX, INLINE-FLEX, FLEX-DIRECTION, COLUMN, ROW, ROW-REVERSE, COLUMN REVERSE */

/* Para trabajar con flexbox se debe aplicar un display: flex a la caja que contiene los elementos que queremos organizar */

#layout {
    /* Esta es la propiedad que se aplica para trabajar con flexbox, hace lo mismo que el float left, a diferencia de que el contenedor si capta el tamaño de los elementos que contiene sin necesidad de un clearfix.
    Entonces, al aplicar el display:flex los elementos contenidos se alinearán uno al lado del otro (flex solo actúa dentro de la caja de forma que no afecta al resto de elementos) */
    display: flex;
    /* Para determinar si una caja con flexbox organiza los elementos vertical u horizontalmente se utiliza la propiedad flex-direction, dicha propiedad tiene row como valor
    por defecto, dicho valor hacer que los elementos se organicen horizontalmente (se colocó la propiedad pero solo para verla copiada, no es necesaria para obtener ese resultado ya que es el valor por defecto).
    Es importante resaltar que las cajas dentro del flexbox se adaptan a su contenido automáticamente, excepto cuando se usa el valor la propiedad en flex-direction:column o column-reverse y la propiedad 
    display: flex, en dicho caso los elementos contenidos abarcar el 100% del elemento padre */
    flex-direction: row;
    /* Se prueba estableciendo un ancho automático pero el ancho automático de los elementos con la propiedad inline-flex es del 100%, por eso al poner la propiedad width: auto el tamaño no se adapta a los elementos
    que contiene */
    width: auto;
    border: 3px solid black;
    padding: 5px;
}

#layout2 {
    /* Con este display se colocan los elementos uno al lado del otro, pero adicionalmente, la caja que contiene los elementos a organizar, se adapta a los mismos, su ancho se adapta automáticamente a lo que 
    contiene, incluso si agregamos más cajas, el contenedor con id layout2 se adapta al contenido */
    display: inline-flex;
    /* La propiedad flex-direction con el valor column hace que la caja que contiene los elementos a organizar, organice los elementos como en una columna (verticalmente). En este caso la caja tiene la propiedad
    display: inline-flex que hace que se adapte al contenido, pero si tuviera la propiedad display: flex, la columna junto a los elementos contenidos abarcarían el 100% del boddy  */
    flex-direction: column;
    margin-top: 25px;
    border: 3px solid black;
    padding: 5px;
}

#layout3 {
    display: flex;
    /* La propiedad flex-direction con el valor row-reverse hace que los elementos contenidos se ubiquen hacia la derecha y en orden inverso, por lo que quedan ahora las cajas organizadas de derecha a izquierda, todo 
    lo contrarios de lo que se hace en la primera caja*/
    flex-direction: row-reverse;
    margin-top: 25px;
    border: 3px solid black;
    padding: 5px;
}

#layout4 {
    /* Se aplicó la propiedad display con el valor flex para ver lo que se mencionó anteriormente, dicho display en conjunto con un flex-direction: column hace que los elementos internos abarquen el 100% del padre */
    display: flex;
    /* Se prueba estableciendo un ancho automático pero el ancho automático de los elementos con la propiedad inline-flex es del 100%, por eso al poner la propiedad width: 100% el tamaño no se adapta a los elementos
    que contiene */
    /* La propiedad flex-direction con el valor column-reverse hace que los elementos se organicen al revés, es decir de abajo a arriba */
    flex-direction: column-reverse;
    margin-top: 25px;
    border: 3px solid black;
    padding: 5px;
}



/* Entonces con las cajas anteriores podemos ver que con las propiedades display: flex y display: inline-flex podemos escoger si queremos que la caja contenedora abarque el 100% del body o si queremos que se adapte 
al contenido respectivamente (la caja al adaptarse se puede centrar utilizando un text-align:center), también pudimos ver cómo funciona la propiedad flex-direction y sus distintos valores. Hubo un valor que no se 
mencionó y es el valor unset, este hace que no se aplique ni column ni row a flex-direction, es decir que hace que se quede con los valores por defecto*/

/* WRAP */

/* En flexbox si integramos bastantes elementos dentro de la caja contenedora y la caja contenedora tiene la propiedad display: flex, los elementos pueden llegar a salirse 
del contenedor, haciendo que se cree un scroll horizontal para poder visualizar los elementos (con display;inline-flex los elementos no se salen de la caja contenedora pero 
igual se crea un scroll horizontal), para evitar este problema se debe usar la propiedad flex-wrap con el valor wrap (no wrap es el valor por defecto y es el valor con el que
tenemos el problema), de esa forma los elementos sobrantes pasarán a posicionarse debajo. Es importante mencionar que este problema se presenta con row o row-inverse, en 
sentido vertical no se salen los elementos de la caja contenedora */

#layout5 {
    display: flex;
    flex-direction: row;
    margin-top: 25px;
    border: 3px solid black;
    padding: 5px;
    /* Esta es la propiedad que se usa para evitar la creación del scroll horizontal y que los elementos salgan de la caja contenedora (si es posible) */
    flex-wrap: wrap;
}

/* FLEX-FLOW */

/* Existe también la propiedad flex-flow que nos permite ahorrarnos una línea de código, porque dicha propiedad puede tener el valor que indica la dirección del flexbox (row o
column, etc.) y si tiene o no wrap (wrap o no wrap), deben copiarse en ese orden flex-flow: dirección wrap */
#layout6 {
    display: flex;
    /* Esta es la propiedad que nos permite colocar la dirección del flexbox y si tiene wrap o no, ahorrando una de las líneas de código que usamos antes, escribiendo solo una */
    flex-flow: row wrap;
    margin-top: 25px;
    border: 3px solid black;
    padding: 5px;
}

/* Esta caja se usó para probar el order de flexbox */
#layout7 {
    display: flex;
    flex-direction: row;
    margin-top: 25px;
    border: 3px solid black;
    padding: 5px;
}



.caja {
    font-size: 20px;
    font-weight: bold;
    text-align: center;
    color: white;
    padding: 20px;
    border: 4px solid #222;
    margin: 10px;
    background-color: gray;
}

/* ORDER (ORDEN DE LOS ELEMENTOS) */

.red {
    background-color: red;
}

.green {
    background-color: green;
}

.blue {
    background-color: blue;
}

.orange {
    background-color: orange;
}

/* Estas clases las creé para aplicar la propiedad order (orden)*/

/* La propiedad order establece el orden en que se presentan los elementos,el valor de esta propiedad debe se run número entero, sin embargo, se deben enumerar todos los 
elementos para que se presente exactamente el orden que deseamos, debemos poner valor -1 para que un solo elemento se coloque de primero y un valor 2 o mayor para que se coloque
de último, pero solo fuciona a´si cuando un solo elemento tiene order, del resto se necesita cpalicar order a todos los elementos. Es muy inportante tener en cuenta que al usar 
el la propiedad flex-direction:row el orden de los elementos es de izquierda a derecha, incluso cuando los reorganizamos y la misma propiedad con el valor row-reverse el orden 
de los elementos es de derecha a izquerda. En el caso de flex-direction:column los elementos se ordenaa de arriba a abajo, incluso cuando los reorganizamos con order, y si se 
utiliza column-reverse, los elementos de ordenan de abajo a arriba */

.caja1 {
    order: 3;
}

.caja2 {
    order: 1;
}

.caja3 {
    order: 4;
}

.caja4 {
    order: 2;
}

/* FLEX-GROW */

/* Creé esta caja para aplicar flex-grow */

#layout8 {
    display: flex;
    flex-direction: row;

    margin-top: 25px;
    border: 3px solid black;
    padding: 5px;
}


/* Ahora se estudiará una propiedad que hará que los elementos contenidos dentro de la caja con display:flex, sean de verdad flexibles, es decir, nos permitirá adaptar el tamaño
de cada elemento contenido a como nos de la gana, dicha propiedad es flex-grow y se agrega a los elementos que son contenidos y no al contenedor como se hace con el resto de las 
propiedades estudiadas hasta ahora, los valores de dicha propiedad son números enteros, y el valor más común es el número 1, con este valor se hace que todas las cajas ocupen el
mismo espacio dentro del contenedor*/

/* Hice esta clase para aplica el flex-grow */
.grow {
    /* Con este valor todos los elementos comparten el mismo espacio y se adaptan de mejor forma cuando se redimensiona la página */
    flex-grow: 1;
}

/* Si se aplica flexgrow a cada cada y se le asigna un número distinto, se indica a cada caja qué tanto espacio pueden ocupar en el contenedor y el resto de las cajas
se adaptarán a este cambio, se puede aplicar a un solo elemento, a varios o a todos. En el siguiente ejemplo se aplicará a todos */

#layout9 {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    margin-top: 25px;
    border: 3px solid black;
    padding: 5px;
}

/* Estas clases las creé para aplicar un flexgrow distintos a cada caja, en este caso las cajas van de pequeño a grande en el siguiente orden: caja cuatro, caja uno, caja tres
y caja dos...entonces, el valor de flex-grow mientras más alto, implica un mayor tamaño del elemento, sin embargo, no importa que tan grande sea el valor, siempre se compartirá
el espacio dentro del contenedor */

.grow1 {
    flex-grow: 3;
}

.grow2 {
    flex-grow: 10;
}

.grow3 {
    flex-grow: 7;
}

.grow4 {
    flex-grow: 2;
}

/* FLEX-SHRINK */

/* La propiedad flex-shrink se puede aplicar a algún elemento flexible para que, cuando se redimensione la página y se comiencen a encoger los elementos flexibles, dicho
elemento con el flex-shrink se encoja más rápido al llegar a un punto extremo del redimensionamiento, es decir, cuando ya no haya espacio suficiente en el contenedor. El valor 
por defecto de esta propiedad es 1, mientras mayor sea el número más rápido se reducirá el elemento al que se le aplicó dicha propiedad, como veremos en el siguiente ejemplo. 
Si se aplica el valor 0, el elemento no se encoge cuando no haya espacio suficiente en el contenedor y el resto si. En resumen, esta propiedad nos permite establecer cómo se 
encogerá un elemento específico al llegar al punto de redimensionamiento que se menciona anteriormente (Esta explicación la busqué por internet ya que Victor no lo explica bien,
de todas formas está el curso de flexbox de John Mircha para consultar)*/

#layout10 {
    display: flex;
    flex-direction: row;
    /* flex-wrap: wrap; */
    margin-top: 25px;
    border: 3px solid black;
    padding: 5px;
}

/* En este caso, cuando se redimensiona la página a un tamaño más pequeño, cuando el contenedor se quede sin espacio, la primera caja se encogerá más rápido que el resto porque
se le estableció un flex-shrink:4 y el valor por defecto es 1 */
.shrink1 {
    flex-shrink: 4;
    flex-grow: 1;
}

.shrink2 {
    flex-grow: 1;
}

.shrink3 {
    flex-grow: 1;
}

.shrink4 {
    flex-grow: 1;
}